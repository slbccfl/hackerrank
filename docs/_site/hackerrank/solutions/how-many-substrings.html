<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=705f1ef6e909910806624131c1d8d28d0641be5f">
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Solutions to HackerRank Exercises and Notes on Lessons Learned</h1>
        <h2>Collection of coding solutions for exercises on hackerrank By Steven Barnes 
        <a href="https://github.com/slbccfl" target="_blank">Github</a>  <a href="https://www.linkedin.com/in/steven-barnes-mba-pmp/" target="_blank">LinkedIn</a></h2>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <a href="http://localhost:4000/hackerrank">Back to Top</a>
<h1>How Many Substrings?</h1>
Find all the unique substrings in a given string of characters.<br><br>
<h2>Problem:</h2>
<p>See HackerRank website for the problem description.<br>
(<a href="https://www.hackerrank.com/challenges/how-many-substrings" target="_blank">HackerRank Problem Description</a>)</p>
<h2 id="solution">Solution:</h2>
<p>Incomplete - Solution is giving correct answers for cases #0 through #3, but timing out on test cases #4 through #10. So the logic is correct, but is just not fast enough yet with the methods tried so far.</p>
<h3 id="strategy">Strategy:</h3>
<p>We need a means for collecting all the substrings of a string while eliminating duplicates of the same substring in this count.</p>

<p>I implemented the Trie data structure to attempt to solve this problem. This does eliminate duplicates and allows me to generate a correct count of all unique substrings. I tried to optimize this solution by excluding cases where the same character repeated from the Trie. And instead calculated the number of substrings in those cases. This was is limited to substrings of a single character repeated. I suspect there are further optimizations possible for repeating substrings beyond a single character. I.e. “abc” repeated 50 times. But after running speed tests I found that collecting and counting these substrings separate from the Trie had inferior performance to just relying on the Trie.</p>

<p>I’ve also tried to think of this as either a recursion problem, where the overall string is broken in half and the respective substrings broken in half and so on to substrings of single characters. And then returning and building up a count from the constituent substrings. But I don’t have a vision of how this would work. The constituent substrings do not stand alone but are part of surrounding substrings too. Take for example, the string “abcabcabc”. While the string “abc” would be found to contain six substrings (“a”, “b”, “c”, “ab”, “bc”, “abc”) the string “abcabcabc” does not contain 3 x 6 substrings as there the substrings “ca”, “bca” and “cab” too.</p>

<p>I’ve also tried to look at this as a dynamic programming problem. Evaluating that the impact of the first character in relation to the balance of the string. And then doing a recursive evaluate of each character relative to the balance of the remaining substring. I suspect that an argument could be made that the trie data structure is effectively doing something like this. The potential first characters of all substrings are the letters connected to the root node. The potential second characters are the subsequent set of nodes connected to the first layer of nodes. And so on. But otherwise I am not seeing a solution for this problem using dynamic programming. At least not yet.</p>

<p>I was suspicious that I had been too clever in my Trie representation. My Trie is defined as with this class:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
class TrieNode {
  boolean isEnd;
  TrieNode[] letterArray;

  public TrieNode() {
    this.letterArray = new TrieNode[26];
  }
}

</code></pre>
</div>
<p>The problem is limited to lower case letters only. Therefore, there are only 26 possible letters for each character in the string. So within each Trie node I create an array of Trie nodes, one for each possible letter. To designate that array cell that applies for a character I use an index based on the character’s Unicode binary value, converting each character to a char and calculating the index with “int index = c - ‘a’;”, where c is the char variable. In some cases a node would have only a couple of array cells used. I suspected that a simple HashMap might be more efficient. So I redefined the Trie as</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
class TrieNode {
  boolean isEnd;
  HashMap&lt;Character, TrieNode&gt; nextLetters;

  public TrieNode() {
    this.nextLetters = new HashMap&lt;Character, TrieNode&gt;();
  }
}

</code></pre>
</div>
<p>and made the appropriate changes in the code using the Trie. Turns out this was significantly slower, so I reset the code back.</p>

<p>The process of slicing the substrings out of the designated string subS has also gone through a number of iterations. Within the loop for the query, I started with a pair of nested loops to slice out all the possible substrings for analysis. This was very brut force and not surprisingly, not optimal. There was one observation that was very informative. Initially these loops traversed the string subS front to back, changing the length of the successive substrings from 1 to the full length of subS. I turned this loop around, to process the longest string, all of subS, down to substrings of length 1. This ran about twice as fast. I suspect that the queries to the Trie finding the chain of characters already in place was faster than building the chain one call to insert into the Trie at a time. This led to a bit of an epiphany. The subsequent inserts into the Trie were only tagging the individual characters along the string as substrings themselves. This was leading to a bunch of unnecessary looping for my purposes. I needed to create the predictable chain of characters in the trie, with every character marked as an ending character. Realizing this, I was able to eliminated the inter loop in main and called method to generate the series of chained trie Nodes instead of using the trie insert method for all the substrings with in the prefix. The new method creates the series of Trie nodes to represent the substring, setting isEnd true for each letter an ending character of a string. The first letter is excluded in the next call and the chain of Trie nodes for that substring is created, and so on down to the last character of subS. This removed an entire loop from the generation of the Trie. Not surprisingly, the performance was nearly an order of magnitude better. What was surprising, and aggravating, was that the submission of this dramatically improved code got the same results on HackerRank. Timing out for testcases #4 through #10. I expected this code to pass at least some additional test cases. WTF?</p>

<p>Since the problem is a analysis of many cuts of substrings from the same string “s” for each query, I keep wondering if there is some way of using information across all of these runs. At the moment each run completely separate from the others. A new Trie is built for each subS string, with no information saved from query to query. I also continue to suspect that there is some way of optimizing for the many repeating series of characters, using a calculated result instead of processing the series into the Trie.</p>

<p>On to the next big idea. I consulted with someone much smarter than me, and he suggested that I look at a compact prefix tree, as an alternative to the Trie (or prefix tree) that I am using. This would store strings at each node, splitting out a portion of the string to a subsidiary node only when there is a difference between two substrings. I was afraid that this approach would result in more or less the same tree as the current Trie as I suspected every node was get broken down to a single character. Nevertheless, I did proceed to retrofit my soltion to implement this approach. This was about five times faster than a simple trie. Which, when submitted to HackerRank, stubbornly give the same result in timeouts from test case #4, on. My implementation of this used the following data structure for the node:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>
class TrieNode {
	boolean isEnd;
	TrieNode parentNode;
	String string;
	TrieNode[] letterArray;

  public TrieNode(int start, int length) {
		this.string = "";
		this.letterArray = new TrieNode[26];
	}
</code></pre>
</div>
<p>From what I read, what I did was move from a prefix trie to a prefix tree. I’m not sure this qualifies as a compact prefix tree. Some of my reading seemed to indicate that a compact prefix tree should use indexes into the original string instead of copying out the relative segements for storage in tree nodes or into variables for comparison. This made a lot of sense to me and I embarked on a further retrofit of my logic to use this data structure:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>class TrieNode {
	boolean isEnd;
	TrieNode parentNode;
	int stringStart;
	int stringEnd;
	TrieNode[] letterArray;

	public TrieNode(int start, int length) {
		this.stringStart = start;
		this.stringEnd = start + length;
		this.letterArray = new TrieNode[26];
	}
</code></pre>
</div>
<p>Getting this code right, using indexes and comparison statements such as the following, was a real pain.</p>
<div class="highlighter-rouge"><pre class="highlight"><code>s.substring(prefixStart, prefixStart + prefixLength).equals(s.substring(currentNode.stringStart, currentNode.stringStart + prefixLength))
</code></pre>
</div>
<p>But I got it working and found that is was slightly <em>slower</em> than just storing the substrings in the nodes and dealing with variable references to them. (<em>Dammit!</em> that was a waste of time… )</p>

<p>What’s left? A lot actually.</p>

<p>During my research I also found references to an algorithm (Ukkonen) that was supposed to be able to find all unique substrings in O(n) time. This required the construction of a suffix tree, instead of a prefix tree. Not that different from what I’m doing. But also includes suffix links to be created during the tree’s constuction. I’m still working on understanding how these links are used. Here are links to some of the best (clearest) of what I’ve referred to:</p>
<ul>
  <li><a href="https://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf" target="\_blank">https://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf</a></li>
  <li><a href="https://stackoverflow.com/questions/9452701/ukkonens-suffix-tree-algorithm-in-plain-english/9513423#9513423" target="\_blank">https://stackoverflow.com/questions/9452701/ukkonens-suffix-tree-algorithm-in-plain-english/9513423#9513423</a></li>
  <li><a href="https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/suffixtrees.pdf" target="\_blank">https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/suffixtrees.pdf</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Suffix_tree#Implementation" target="\_blank">https://en.wikipedia.org/wiki/Suffix_tree#Implementation</a></li>
</ul>

<p>There is also this definition of a suffix array, that indicates that there are advantages over suffix trees:</p>
<ul>
  <li><a href="https://en.wikipedia.org/wiki/Suffix_array" target="\_blank">https://en.wikipedia.org/wiki/Suffix_array</a></li>
</ul>

<h3 id="methods">Methods:</h3>

<h4 id="main">main</h4>
<p>The main method uses BufferReader to read the inputs, with a for loop to take in the left and right indexes that identify the portion of the string “s” to be evaluated for each query, which is assigned to subS.</p>

<h3 id="data-structures">Data Structures:</h3>

<a href="http://localhost:4000/hackerrank">Back to Top</a>

      </section>
    </div>

  </body>
</html>
